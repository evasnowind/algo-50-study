# Dynamic Programming  

## Basic Concept  

动态规划问题一定会具备「最优子结构」

然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。

思考过程：
```
明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。
```

解决问题的基本模板：
```
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

## 优化技巧1：使用「备忘录」  

「备忘录」 可以解决重叠子问题所带来的重复计算。

- 每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；
- 每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

例子：使用备忘录解决斐波那契数列问题
```cpp
int fib(int N) {
    if (N < 1) return 0;
    // 备忘录全初始化为 0
    vector<int> memo(N + 1, 0);
    // 进行带备忘录的递归
    return helper(memo, N);
}

int helper(vector<int>& memo, int n) {
    // base case 
    if (n == 1 || n == 2) return 1;
    // 已经计算过
    if (memo[n] != 0) return memo[n];
    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
}
```

**带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。**   

##  优化技巧2：状态压缩  

根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：

```
int fib(int n) {
    if (n == 2 || n == 1) 
        return 1;
    int prev = 1, curr = 1;
    for (int i = 3; i <= n; i++) {
        int sum = prev + curr;
        prev = curr;
        curr = sum;
    }
    return curr;
}
```


## 找出状态转移方程  

这个是最困难的一步。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。

如何列出正确的状态转移方程？

1、确定 base case
2、确定「状态」，也就是原问题和子问题中会变化的变量。
3、确定「选择」，也就是导致「状态」产生变化的行为。
4、明确 dp 函数/数组的定义。

**递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间。**


## 示例 

### 1、凑零钱问题  


